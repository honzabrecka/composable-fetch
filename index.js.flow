// @flow

export type UnaryFn<A, B> = ((value: A) => B) | ((value: A) => Promise<B>)

export type UnaryFnP<A, B> = (value: A) => Promise<B>
// declare type Pipe = (<A, B, C, D, E, F, G>(
//   ab: UnaryFn<A, B>,
//   bc: UnaryFn<B, C>,
//   cd: UnaryFn<C, D>,
//   de: UnaryFn<D, E>,
//   ef: UnaryFn<E, F>,
//   fg: UnaryFn<F, G>,
// ) => UnaryFnP<A, G>) &
//   (<A, B, C, D, E, F>(
//     ab: UnaryFn<A, B>,
//     bc: UnaryFn<B, C>,
//     cd: UnaryFn<C, D>,
//     de: UnaryFn<D, E>,
//     ef: UnaryFn<E, F>,
//   ) => UnaryFnP<A, F>) &
//   (<A, B, C, D, E>(
//     ab: UnaryFn<A, B>,
//     bc: UnaryFn<B, C>,
//     cd: UnaryFn<C, D>,
//     de: UnaryFn<D, E>,
//   ) => UnaryFnP<A, E>) &
//   (<A, B, C, D>(
//     ab: UnaryFn<A, B>,
//     bc: UnaryFn<B, C>,
//     cd: UnaryFn<C, D>,
//   ) => UnaryFnP<A, D>) &
//   (<A, B, C>(ab: UnaryFn<A, B>, bc: UnaryFn<B, C>) => UnaryFnP<A, C>) &
//   (<A, B>(ab: UnaryFn<A, B>) => UnaryFnP<A, B>)

export type Encoder<A, B> = (value: A) => B

export type Request = {
  url: string | URL,
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE',
  headers?: { [string]: string },
  body?: any,
  [string]: any,
}

// declare export type Response = any

export type RetryableFetch = () => Promise<Response>

export type Delay = (t: number) => Promise<void>

export type Effect = (t: number) => any

declare export var delays: {
  constant: (time?: number, f?: Effect) => Delay,
  exponential: (time?: number, f?: Effect) => Delay,
  limited: (max: number, delay: Delay) => Delay,
  linear: (time?: number, f?: Effect) => Delay,
}

export type UnaryFetch = (req: Request) => Promise<Response>

export type BinaryFetch = (
  url: string | URL,
  init: any,
) => Promise<Response>

export type RetryOptions = {
  max?: number,
  delay?: Delay,
  maxTimeout?: number,
}

declare export var composableFetch: {
  checkStatus: (res: Response) => Response,
  decodeArrayBufferResponse: (res: Response) => Response,
  decodeBlobResponse: (res: Response) => Response,
  decodeFormDataResponse: (res: Response) => Response,
  decodeJSONResponse: (res: Response) => Response,
  decodeResponse: (res: Response) => Response,
  decodeTextResponse: (res: Response) => Response,
  fetch: UnaryFetch,
  fetch1: (fetch: BinaryFetch) => UnaryFetch,
  logError: (log: Function) => (error: Error) => Promise<void>,
  retryable: (fetch: UnaryFetch) => (req: Request) => RetryableFetch,
  retryableFetch: (req: Request) => RetryableFetch,
  withBaseUrl: (baseUrl: string) => (req: Request) => Request,
  withEncodedBody: <A, B>(
    encoder: Encoder<A, B>,
  ) => (req: Request) => Request,
  withHeader: (header: string, value: string) => (req: Request) => Request,
  withCredentials: (value: 'omit' | 'same-origin' | 'include') => (req: Request) => Request,
  withRetry: (options?: RetryOptions) => (fetch: RetryableFetch) => Promise<Response>,
  withSafe204: (text?: string, json?: any) => (res: Response) => Response,
  withTimeout: (
    timeout: number,
  ) => (fetch: RetryableFetch) => RetryableFetch,
  withClone: (res: Response) => Response,
  decodeRetryAfterHeaderValue: Function,
  json: (options?: RetryOptions) => Promise<Response>,
  text: (options?: RetryOptions) => Promise<Response>,
}

declare export var pipeP: <A, B>(...fns: Function[]) => UnaryFnP<A, B>

declare export var tryCatchP: <A, B>(
  trier: (value: A) => Promise<B>,
  catcher: (err: Error, value: A) => Promise<B>,
) => UnaryFnP<A, B>
